admin_password: null
affinity: {}
celery_app_name: cloudlaunchserver
container_name: cloudlaunchserver
django_dir: /app/django-cloudlaunch
django_settings_module: cloudlaunchserver.settings_prod
env_prefix: CLOUDLAUNCH
extra_config_mounts: []
extra_env: {}
extra_init_scripts: {}
extra_secret_mounts: []
extraVolumeMounts: ""
extraVolumes: ""
fernet_keys: []
image:
  pullPolicy: IfNotPresent
  repository: cloudve/cloudlaunch-server
  tag: latest
ingress:
  annotations: {}
  enabled: false
  hosts:
  - null
  path: /
  protocol: https
  tls: []
initial_data:
- 1_clouds.json: true
- 2_appliances.json: true
nameOverride: cloudlaunch
nodeSelector: {}
podAnnotations: {}
postgresql:
  enabled: true
  extraEnv: []
  global:
    postgresql: {}
  image:
    debug: false
    pullPolicy: IfNotPresent
    registry: docker.io
    repository: bitnami/postgresql
    tag: 11.6.0-debian-10-r5
  ldap:
    baseDN: ""
    bind_password: null
    bindDN: ""
    enabled: false
    port: ""
    prefix: ""
    scheme: ""
    search_attr: ""
    search_filter: ""
    server: ""
    suffix: ""
    tls: false
    url: ""
  livenessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  master:
    affinity: {}
    annotations: {}
    extraInitContainers: ""
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    nodeSelector: {}
    podAnnotations: {}
    podLabels: {}
    priorityClassName: ""
    tolerations: []
  metrics:
    enabled: false
    image:
      pullPolicy: IfNotPresent
      registry: docker.io
      repository: bitnami/postgres-exporter
      tag: 0.8.0-debian-10-r4
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    prometheusRule:
      additionalLabels: {}
      enabled: false
      namespace: ""
      rules: []
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    securityContext:
      enabled: false
      runAsUser: 1001
    service:
      annotations:
        prometheus.io/port: "9187"
        prometheus.io/scrape: "true"
      loadBalancerIP: null
      type: ClusterIP
    serviceMonitor:
      additionalLabels: {}
      enabled: false
  networkPolicy:
    allowExternal: true
    enabled: false
  persistence:
    accessMode: ReadWriteMany
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: true
    mountPath: /bitnami/postgresql
    size: 8Gi
    subPath: ""
  postgresqlDataDir: /bitnami/postgresql/data
  postgresqlDatabase: cloudlaunch
  postgresqlUsername: cloudlaunch
  readinessProbe:
    enabled: true
    failureThreshold: 6
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  replication:
    applicationName: my_application
    enabled: false
    numSynchronousReplicas: 0
    password: repl_password
    slaveReplicas: 1
    synchronousCommit: "off"
    user: repl_user
  resources:
    requests:
      cpu: 250m
      memory: 256Mi
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  service:
    annotations: {}
    port: 5432
    type: ClusterIP
  serviceAccount:
    enabled: false
  shmVolume:
    chmod:
      enabled: true
    enabled: true
  slave:
    affinity: {}
    annotations: {}
    extraInitContainers: ""
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    nodeSelector: {}
    podAnnotations: {}
    podLabels: {}
    priorityClassName: ""
    tolerations: []
  updateStrategy:
    type: RollingUpdate
  volumePermissions:
    enabled: true
    image:
      pullPolicy: Always
      registry: docker.io
      repository: bitnami/minideb
      tag: stretch
    securityContext:
      runAsUser: 0
rabbitmq:
  rabbitmqErlangCookie: mustRemainSameBetweenUpgrades
  rabbitmqUsername: notAGuest
  replicaCount: 1
rabbitmq-ha:
  advancedConfig: ""
  busyboxImage:
    pullPolicy: IfNotPresent
    repository: busybox
    tag: 1.30.1
  clusterDomain: cluster.local
  definitions:
    bindings: ""
    exchanges: ""
    globalParameters: ""
    parameters: ""
    permissions: ""
    policies: ""
    queues: ""
    users: ""
    vhosts: ""
  definitionsSource: definitions.json
  env: {}
  existingConfigMap: false
  existingSecret: ""
  extraConfig: ""
  extraContainers: []
  extraInitContainers: []
  extraLabels: {}
  extraPlugins: |
    rabbitmq_shovel,
    rabbitmq_shovel_management,
    rabbitmq_federation,
    rabbitmq_federation_management,
  extraVolumeMounts: []
  extraVolumes: []
  forceBoot: false
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: rabbitmq
    tag: 3.8.0-alpine
  ingress:
    annotations: {}
    enabled: false
    path: /
    tls: false
    tlsSecret: myTlsSecret
  initContainer:
    resources: {}
  lifecycle: {}
  livenessProbe:
    exec:
      command:
      - /bin/sh
      - -c
      - 'wget -O - -q --header "Authorization: Basic `echo -n \"$RABBIT_MANAGEMENT_USER:$RABBIT_MANAGEMENT_PASSWORD\"
        | base64`" http://localhost:15672/api/healthchecks/node | grep -qF "{\"status\":\"ok\"}"'
    failureThreshold: 6
    initialDelaySeconds: 120
    periodSeconds: 10
    timeoutSeconds: 5
  managementUsername: management
  nodeSelector: {}
  persistentVolume:
    accessModes:
    - ReadWriteOnce
    annotations: {}
    enabled: false
    name: data
    size: 8Gi
  podAnnotations: {}
  podAntiAffinity: soft
  podAntiAffinityTopologyKey: kubernetes.io/hostname
  podDisruptionBudget: {}
  podManagementPolicy: OrderedReady
  prometheus:
    exporter:
      capabilities: bert,no_sort
      enabled: false
      env: {}
      image:
        pullPolicy: IfNotPresent
        repository: kbudde/rabbitmq-exporter
        tag: v0.29.0
      port: 9090
      resources: {}
    operator:
      alerts:
        enabled: true
        labels: {}
        selector:
          role: alert-rules
      enabled: true
      serviceMonitor:
        interval: 10s
        namespace: monitoring
        selector:
          prometheus: kube-prometheus
  rabbitmqAmqpsSupport:
    amqpsNodePort: 5671
    config: |
      # listeners.ssl.default             = 5671
      # ssl_options.cacertfile            = /etc/cert/cacert.pem
      # ssl_options.certfile              = /etc/cert/cert.pem
      # ssl_options.keyfile               = /etc/cert/key.pem
      # ssl_options.verify                = verify_peer
      # ssl_options.fail_if_no_peer_cert  = false
    enabled: false
  rabbitmqAuth:
    config: |
      # auth_mechanisms.1 = PLAIN
      # auth_mechanisms.2 = AMQPLAIN
      # auth_mechanisms.3 = EXTERNAL
    enabled: false
  rabbitmqAuthHTTP:
    config: |
      # auth_backends.1 = http
      # auth_http.user_path     = http://some-server/auth/user
      # auth_http.vhost_path    = http://some-server/auth/vhost
      # auth_http.resource_path = http://some-server/auth/resource
      # auth_http.topic_path    = http://some-server/auth/topic
    enabled: false
  rabbitmqCert:
    cacertfile: ""
    certfile: ""
    enabled: false
    existingSecret: ""
    keyfile: ""
  rabbitmqClusterPartitionHandling: autoheal
  rabbitmqEpmdPort: 4369
  rabbitmqHipeCompile: false
  rabbitmqLDAPPlugin:
    config: |
      # auth_backends.1 = ldap
      # auth_ldap.servers.1  = my-ldap-server
      # auth_ldap.user_dn_pattern = cn=${username},ou=People,dc=example,dc=com
      # auth_ldap.use_ssl    = false
      # auth_ldap.port       = 389
      # auth_ldap.log        = false
    enabled: false
  rabbitmqMQTTPlugin:
    config: |
      # mqtt.default_user     = guest
      # mqtt.default_pass     = guest
      # mqtt.allow_anonymous  = true
    enabled: false
  rabbitmqManagerPort: 15672
  rabbitmqMemoryHighWatermark: 256MB
  rabbitmqMemoryHighWatermarkType: absolute
  rabbitmqNodePort: 5672
  rabbitmqPrometheusPlugin:
    config: |
      ## prometheus.path and prometheus.tcp.port can be set above
    enabled: false
    nodePort: null
    path: /metrics
    port: 15692
  rabbitmqSTOMPPlugin:
    config: |
      # stomp.default_user = guest
      # stomp.default_pass = guest
    enabled: false
  rabbitmqUsername: guest
  rabbitmqVhost: /
  rabbitmqWebMQTTPlugin:
    config: |
      # web_mqtt.ssl.port       = 12345
      # web_mqtt.ssl.backlog    = 1024
      # web_mqtt.ssl.certfile   = /etc/cert/cacert.pem
      # web_mqtt.ssl.keyfile    = /etc/cert/cert.pem
      # web_mqtt.ssl.cacertfile = /etc/cert/key.pem
      # web_mqtt.ssl.password   = changeme
    enabled: false
  rabbitmqWebSTOMPPlugin:
    config: |
      # web_stomp.ws_frame = binary
      # web_stomp.cowboy_opts.max_keepalive = 10
    enabled: false
  rbac:
    create: true
  readinessProbe:
    exec:
      command:
      - /bin/sh
      - -c
      - 'wget -O - -q --header "Authorization: Basic `echo -n \"$RABBIT_MANAGEMENT_USER:$RABBIT_MANAGEMENT_PASSWORD\"
        | base64`" http://localhost:15672/api/healthchecks/node | grep -qF "{\"status\":\"ok\"}"'
    failureThreshold: 6
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 3
  replicaCount: 3
  resources: {}
  securityContext:
    fsGroup: 101
    runAsGroup: 101
    runAsNonRoot: true
    runAsUser: 100
  service:
    amqpNodePort: null
    annotations: {}
    clusterIP: None
    epmdNodePort: null
    externalIPs: []
    loadBalancerIP: ""
    loadBalancerSourceRanges: []
    managerNodePort: null
    type: ClusterIP
  serviceAccount:
    automountServiceAccountToken: true
    create: true
  statefulSetAnnotations: {}
  terminationGracePeriodSeconds: 10
  tolerations: []
  updateStrategy: OnDelete
replicaCount: 1
resources: {}
secret_key: null
sentry_dns: null
service:
  port: 8000
  type: ClusterIP
tolerations: []
